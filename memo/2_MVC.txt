MVC 패턴이란??
	애플리케이션 개발을 MVC로 구분하여 각 역할에 맞게 코드를 작성하는 방식.
	MVC (Model , View, Controller)

MVC의 구성 요소
	Model 	: 데이터베이스와의 상호 작용하며 결과 데이터를 클라이언트에게 돌려줄 때 사용한다.
	View 	: 사용자에게 보여지는 화면, 모델 데이터를 표시하고 입력받는 역할을 함. 
	Controller	: 사용자 입력을 처리하고 모델과 뷰를 연결. 모델을 업데이트하고 뷰를 선택함.

※ Restful : 페이지 이동없이 서버로부터 데이터를 받아오는 경우

MVC 1 패턴
	MVC1 패턴이란??
		요청이 처리 결과를 DB로부터 받은 Model 객체를 JSP(Java Server Page)에 담아 응답을 보내는 패턴
		단, JSP가 View와 Controller를 모두 담당하므로 JSP 내에 너무 많은 코드가 들어가게 되어 가독성이 떨어진다.

	※ DB로부터 받은 Mode 객체 : 테이블 각각의 컬럼(key)에 값(value)을 넣어서 만든 데이터
	※ .jsp 는 html 안에 java 코드를 작성할 수 있도록 도와준다.

		   ---> 
클라이언트		    View(Controller) <-> Model <-> DB
		   <---

================================================================================
5월 28일(화)


MVC 2
	MVC 1 패턴에 Front Controller 가 추가된 형태
	※ Front Controller : MVC 2의 핵심, 모든 요청(url)을 중앙 집중식으로 처리한다.
	
	1. 사용자의 모든 요청이 Front Controller로 들어옴.
	2. 요청을 분석하고 적절한 컨트롤러에  전달 ( >> ★ Front Controller의 핵심적인 역할 )
	3. 컨트롤러는 비즈니스 로직을 수행하고 모델을 업데이트한 후 결과를 뷰에 전달한다.
	4. Front Controller 는 최종적으로 뷰를 랜더링하여 사용자에게 응답을 반환한다.

Spring MVC
	스프링 프레임워크에서 MVC 2 모델을 좀 더 발전시킨 형태
	
	1. 클라이언트가 서버에 요청을 하면, Front Controller인 DispatcherServlet 클래스가 요청을 받는다.
	2. DispatcherServlet은 HandlerMapping 에게 요청이 들어온 url 와 매핑되는 컨트롤러 검색을 요청하고, 찾게 되면 해당 컨트롤러를 반환한다.
	3. 반환 받은 컨트롤러로 "클라이언트의 요청 처리"를 요청한다.
	4. Controller는 해당 비즈니스 로직을 수행한 후 결과를 반환한다.
	5. 반환하는 html이 있다면 ViewResolver 에게 html을 찾아달라고 요청하고, 찾으면 반환한다.
	6. 최종적으로 DispatcherServlet이 응답할 View의 랜더링을 지시한다.
	7. 최종 랜더링을 수행한 후에 마무리한다.

스프링의 특징
	1. IoC란?? (Inversion of Control ; 제어의 역전)
		순수 자바프로젝트에서 객체를 생성할 때는 객체가 필요한 곳에 개발자가 직접 생성을 했다.
		제어의 역전 
			다른 객체를 개발자가 직접 생성하거나 제어하는 것이 아니라 
			외부에서 관리하는 객체를 가져와 사용하는 것을 말함.
	
		※ 스프링에서는 스프링 컨테이너가 객체를 관리, 제공하는 역할을 한다.	

	2. DI 란?? (Dependency Injection ; 의존성 주입)
		제어의 역전을 구현하기 위해 사용하는 방법
		의존성 주입 : 클래스가 다른 클래스에 의존한다는 뜻.

		의존 : A 객체가 B 객체없이 동작이 불가능한 상황을 'A가 B에 의존적이다.' 라고 표현한다.
		주입 
			어떤 객체가 필요로 하는 객체를 외부에서 밀어 넣는 것을 의미. 
			주입을 받는 입장에서는 어떤 객체인지 신경쓸 필요가 없고, 어떤 객체에 의존하든 자신의 역할은 
			변하지 않는다.

	
		그런데 우리가 생각했을 때 A클래스에서 B클래스 안에 있는 메서드를 사용하기 위해서는 B클래스의 정보를
		메모리 상에 올리고 사용할 수 있었다. ( 즉, 객체를 만들어서 해당 위치에 있는 필드에 접근할 수 있었다. )
		
		근데 문법을 살펴보면 생성자를 호출하는 문법 자체가 없다. 
		메모리에 할당이 되지 않았는데 필드를 사용할 수 있는 것은 말이 안 된다.
		하지만 동작이 잘 되는 이유는 스프링 컨테이너(외부)에서 객체를 주입했기 떄문이다.
	
		요약정리
			스프링의 경우 클래스 A에서 B객체를 쓰고 싶은 경우, 
			객체를 직접 생성하는 것이 아니라 스프링 컨테이너에서 객체를 주입받아 사용한다.
			( IoC(제어의 역전)을 구현하기 위해 DI(의존성 주입)을 사용한다. )

	※ 
		DI 를 사용하면 클래스는 자신의 의존성을 생성자를 호출하여 생성하지 않고, 외부(스프링 컨테이너)에서 주입 받는다.

		이는 클래스가 구체적인 구현에 의존하지 않고 인터페이스에 의존하게 되어 의존성 주입의 대상이 바뀌더라도
		클래스 자체의 수정은 필요가 없어진다. 이로 인해서 클래스 간의 결합도는 낮아진다.
	
스프링 컨테이너
	스프링 컨테이너는 Bean(객체)을 생성 및 관리한다.
	Bean이 생성되고 소멸되기까지의 생명 주기(라이프 사이클)을 관리한다.
	그리고 스프링 컨테이너에 있는 Bean(객체)을 사용하려면, @Autiwired 어노테이션을 사용해서 Bean을 주입받는다.

Bean 
	스프링 컨테이너가 생성 및 관리하는 객체
	스프링에서 제공해주는 객체

	Bean을 등록하는 방법
		1. xml 파일 설정 (Spring Framework)
		2. Annotation을 이용한 등록 (Spring boot) -> @Autowired

IoC, DI 의 장점
		1. 객체 간 결합도를 떨어트린다.
			스프링 컨테이너를 통해 참조 받는 방식입니다. 객체 간의 결합도를 낮춰서 수정 시, 영향을 덜 받게 합니다.			

		2. 테스트의 용이성
			DI를 통해 Mock(가짜, 모의) 객체를 주입할 수 있어 단위 테스트가 편해진다.
			테스트 코드에서는 실제 구현체를 사용하지 않는다. 
			( 실제 코드가 변경되는 것을 방지하기 위해 테스트 코드를 통해 테스트를 진행한다. )
			
		3. 유연성과 확장성
			DI를 사용하면 필요한 정보를 외부에서 주입 받기 때문에 프로젝트의 유연성이 높아진다.
			환경 설정을 쉽게 변경할 수 있고 새로운 코드를 추가하는 식으로 확장도 편하게 할 수 있다.
	
		4. 재사용성 증가
			스프링 컨테이너가 빈을 관리하기 때문에 다양한 곳에서 재사용을 편하게 할 수 있다.
			이는 코드의 중복을 줄이고 중앙에서 객체를 쉽게 관리할 수 있다.


AOP (Aspect Oriented Programming ; 관점 지향 프로그래밍)
	프로그래밍에 대한 관심을 핵심 관점, 부가 관점으로 나누어서 관심 기준으로 모듈화하는 것을 의미합니다.

	핵심 관점 : 게시글 작성, 회원가입
	부가 관점 : 데이터베이스 연결, 로깅 등등
	
	부가 관점에 해당하는 로직을 모듈화하면 핵심 관점 코드에만 집중할 수 있게 될 뿐만 아니라
	프로그램의 변경과 확장에도 유연하게 대응할 수 있다.
	
OOP(객체 지향 프로그래밍) 와 AOP(관점 지향 프로그래밍)의 비교
	OOP
		데이터와 기능을 객체 단위로 묶어서 모듈화하는 프로그래밍, 상속과 다형성을 통해 코드를 재사용, 시스템 구조가 명확해진다.

	AOP
		공통된 부가 관점을 모듈화하여 비즈니스 로직(핵심 관점)과 분리하고, 코드의 재사용성과 유지보수성을 높인다.
		모듈화 해놓은 부가 관점은 여러 모듈에서 재사용할 수 있다.










	




















